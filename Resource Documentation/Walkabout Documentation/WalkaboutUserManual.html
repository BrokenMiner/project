<!DOCTYPE html><html><head>	<title>User Manual | Walkabout</title>	<link rel="stylesheet" type="text/css" href="style.css">	<link rel="stylesheet" type="text/css" href="bootstrap.min.css"></head><body>	<div class="container"><div class="row">	<a href="WalkaboutDocumentation.html"><img src="images/walkabout.png" class="banner" /></a>	<p class="title">USER MANUAL</p>	<p>So you've played around with the nav editor a bit, but now you want to learn more about what you can do with <strong>Walkabout</strong>.	This is the guide for you! As well as being an in-depth reference manual for <strong>Walkabout</strong>'s features, this document will provide	you with the knowledge required to make full use of <strong>Walkabout</strong>'s editor and script interfaces.</p>	<p class="title">CONTENTS</p>	<ol class="toc">	<li><a href="#editor">Nav Editor</a>	<ol>		<li><a href="#editor-overview">Overview</a>		<ol>			<li><a href="#editor-interface">The interface</a></li>			<li><a href="#editor-palette">The palette</a></li>			<li><a href="#editor-inspector">Inspector tree</a></li>			<li><a href="#editor-actions">Actions panel</a></li>			<li><a href="#editor-properties">Properties panel</a></li>			<li><a href="#editor-console">The console</a></li>		</ol></li>		<li><a href="#inspect-mode">Inspect mode</a>		<ol>			<li><a href="#build-properties">Build properties</a></li>			<li><a href="#character-properties">Character properties</a></li>			<li><a href="#editing-properties">Editing properties</a></li>		</ol></li>		<li><a href="#link-mode">Link mode</a></li>		<li><a href="#cover-mode">Cover mode</a></li>		<ol>			<li><a href="#cover-properties">Cover properties</a></li>		</ol></li>		<li><a href="#tile-mode">Tile mode</a></li>		<li><a href="#test-mode">Test mode</a></li>	</ol></li>	<li><a href="#scripting">Scripting</a>	<ol>		<li><a href="#scripting-aiplayer">AIPlayer</a>		<ol>			<li><a href="#aiplayer-pathfinding">Pathfinding</a></li>			<li><a href="#aiplayer-followpath">Following paths</a></li>			<li><a href="#aiplayer-followobject">Following objects</a></li>			<li><a href="#aiplayer-cover">Finding cover</a></li>			<li><a href="#character-types">Character types</a></li>		</ol></li>		<li><a href="#scripting-navmesh">NavMesh</a>		<ol></li>			<li><a href="#navmesh-obstacles">Obstacles</a></li>			<li><a href="#navmesh-building">Building</a></li>			<li><a href="#navmesh-links">Link manipulation</a></li>		</ol></li>		<li><a href="#scripting-navpath">NavPath</a></li>		<li><a href="#scripting-coverpoint">CoverPoint</a></li>	</ol></li>	</ol>	<h1 id="editor">Nav Editor</h1>	<h2 id="editor-overview">Overview</h2>	<p>The Nav editor is designed to help you perform the most common tasks you'll need to do when setting up <strong>Walkabout</strong> navigation in your game.	While Recast fully automates the process of actually creating a NavMesh, there are lots of ways to tweak and modify the process,	as well as tasks to do that cannot be automated, such as tweaking cover points and jump links.</p>	<h3 id="editor-interface">The interface</h3>	<p>When you open up the nav editor, you'll see something like the image below.	The following sections explain each of the highlighted interface features.</p>	<img src="images/editor.png" />	<p class="caption">The Nav Editor interface in Inspect mode.</p>	<h3 id="editor-palette">The palette</h3>	<p>The palette is where you switch between the different modes the nav editor offers.	Each mode has a particular set of functions associated with it.	The Actions panel and Properties panel show different content specific to the mode the editor is in.</p>	<table class="table">		<tr><th>Icon</th> <th>Mode</th> <th>Description</th>				<tr><td><img src="images/button-inspect.png" class="inline" /></td> <td><a href="#inspect-mode">Inspect</a></td> <td>Allows you to edit NavMesh properties and build entire NavMeshes.</td></tr>		<tr><td><img src="images/button-link.png" class="inline" /></td> <td><a href="#link-mode">Link</a></td> <td>Lets you edit jump links.</td></tr>		<tr><td><img src="images/button-cover.png" class="inline" /></td> <td><a href="#cover-mode">Cover</a></td> <td>Lets you auto-generate and tweak CoverPoints.</td></tr>		<tr><td><img src="images/button-tile.png" class="inline" /></td> <td><a href="#tile-mode">Tile</a></td> <td>A debug viewer and a way to rebuild individual tiles in the editor.</td></tr>		<tr><td><img src="images/button-test.png" class="inline" /></td> <td><a href="#test-mode">Test</a></td> <td>Let some AIPlayers loose on your level!</td></tr>	</table>	<h3 id="editor-inspector">Inspector tree</h3>	<p>This window is visible in all nav editor modes, showing you a list of all NavMesh objects in your mission.	You can select NavMeshes here, and create new ones as well.</p>	<div class="alert alert-warning">		<p><strong>IMPORTANT!</strong>		Most operations in the following editor modes rely on a NavMesh being selected, so if you're pressing buttons and nothing's happening, glance at the Inspector!</p>	</div>	<h3 id="editor-actions">Actions panel</h3>	<p>This area contains buttons that perform actions specific to the current mode you're in.	For example, in Inspect mode, this panel contains the button that builds the NavMesh, whereas in Cover mode, it has a button that creates cover points.</p>	<h3 id="editor-properties">Properties panel</h3>	<p>This area enables you to view and change options relevant to the current mode you're in.	For example, in Inspect mode, this window is an inspector that lets you view and edit all the console members of the currently-selected NavMesh.	In Tile mode, it contains rendering options.</p>	<h3 id="editor-console">The console</h3>	<p>In the Nav editor toolbar, the <img src="images/button-console.png" class="inline" /> button opens the console.	This small window contains output data from the navmesh build process, including build times and any errors.	Typically, you should not need to use it.</p>	<h2 id="inspect-mode">Inspect mode</h2>	<p>This mode lets you view the properties of each NavMesh in your level (using the browser in the top-left).	The default NavMesh properties should work well for small- to medium-sized NavMeshes,	but if you have a special situation or want to tweak your NavMesh's performance, here's a guide to a few of the different parameters that affect NavMeshes:</p>	<h3 id="build-properties">Build properties</h3>	<table class="table">		<tr><th>Member</th><th>Description</th></tr>		<tr><td>cellSize</td> <td>The size (in metres) of the voxel cells your geometry is turned into. 		ou can view voxels using Tile mode (see below).		Smaller values mean builds take longer (because there are more voxels to process), but the results will be closer to your actual level geometry.</td></tr>		<tr><td>cellHeight</td> <td>The height (in metres) of the voxels.		Smaller values mean that the NavMesh sits closer to surfaces.		In general, cellSize and cellHeight should be roughly the same.</td></tr>		<tr><td>walkableRadius</td> <td>The distance away from walls and corners the NavMesh should maintain.		You should set this close to the radius of a typical character who will use the mesh.</td></tr>		<tr><td>walkableHeight</td> <td>How tall a character can be! This affects areas with overhangs.</td></tr>		<tr><td>walkableClimb</td> <td>Size of ledges a character can climb or jump up.		Beware when using large cellHeight values - sometimes voxels on a slope can be treated as a ledge, and the NavMesh will be generated oddly.		If your mesh doesn't appear on slopes where it should, try making walkableClimb larger than cellHeight.</td></tr>		<tr><td>tileSize</td> <td>To allow larger meshes and faster build-times (as well as real-time rebuilds), NavMeshes are split into tiles.		This property defines the dimensions of each tile in metres. You can view a NavMesh's tiles in Tile mode (see below).</td></tr>		<tr><td>maxTiles</td> <td>The maximum number of tiles the mesh is allowed to generate.		If your navmesh doesn't cover the entire area defined by its box, try increasing this limit!</td></tr>		<tr><td>maxPolysPerTile</td> <td>As its name suggests, this is a limit upon the number of polygons in each NavMesh tile.		If some of your very dense tiles seem to be built incorrectly, try increasing this number.</td></tr>	</table>	<h3 id="character-properties">Character properties</h3>	<table class="table">		<tr><td>smallCharacters</td> <td>Allows 'small' type characters to use this NavMesh. For more information on character sizes, see the section on Character types below.</td></tr>		<tr><td>regularCharacters</td> <td>Allows regular-sized characters to use this NavMesh.</td></tr>		<tr><td>largeCharacters</td> <td>Allows large characters to use this NavMesh.</td></tr>		<tr><td>vehicles</td> <td>Allows characters who drive vehicles to use this NavMesh.		Whenever an AIPlayer is mounted to a Vehicle, they will try to only use NavMeshes with this property set.</td></tr>	</table>	<h3 id="editing-properties">Editing properties</h3>	<table class="table">		<tr><td>saveIntermediates</td> <td>If this box is checked, the engine will save the intermediate data generated during a NavMesh build,		allowing you to view debug information in Tile mode. You should only check this if there's a problem with your NavMesh and you want to debug it.</td></tr>		<tr><td>backgroundBuild</td> <td>When checked, your NavMesh will not build instantly, but spread the process over a longer period of time.		This lets you keep editing while the NavMesh builds.</td></tr>		<tr><td>fileName</td> <td>If this filename is not blank, when you save your mission, the NavMesh data will be saved to this file,		and loaded up from it when you re-load the mission. You should always use this feature, except in very special circumstances!</td></tr>	</table>	<h2 id="link-mode">Link mode</h2>	<p>This mode allows you to connect parts of your NavMesh using one-way links that signify some method of moving not accounted for by the mesh itself -	such as jumping down a ledge, using a teleporter, or climbing a ladder.</p>	<img src="images/link.png" />	<p class="caption">Example of an off-mesh link.</p>	<p>The image above is a good example of a link - the white line connects the NavMesh across a small ledge where a character might be able to drop down if they're in a hurry!</p>	<ul>		<li>Left-click with no link already selected to create a new link - your first click defines the link's starting point, and your second its end point.		Until you rebuild the NavMesh, the link will be rendered red, to remind you that characters won't use it yet.</li>		<li>Hold shift while creating a second point to maintain the starting point, so you can add multiple links from the same starting point efficiently.</li>		<li>Left-click to select a link, which allows you to inspect its properties.</li>		<li>Delete a selected link with the delete key. Until you rebuild the NavMesh, the link will still be rendered, red in colour, and without the circles at its head and tail.		This reminds you that until the mesh is rebuilt, characters will still use that link for pathfinding!</li>	</ul>	<p>After modifying links, you'll need to re-build your NavMesh to enable them - after doing this, the links will change colour from red to black.	Using the 'rebuild links' button in the Actions panel rebuilds only the parts of your NavMesh where links have ben edited.</p>	<p>Links can have different types.	When youplace a link, it is automatically classified based on its dimensions.	If a link travels more horizontally than it drops, it is classified as a jump - otherwise, it's a drop.	You can manually edit the type of a link you have selected in the 'properties' window on the left.	Note that a link may belong to any combination of possible tyeps.	The different types are described below.</p>	<table class="table">		<tr><th>Type</th><th>Description</th></tr>		<tr><td>Walk</td><td>Signifies movement over open, dry land.</td></tr>		<tr><td>Jump</td><td>Tells the character that they must jump immediately to use this link.</td></tr>		<tr><td>Drop</td><td>Signifies that a small drop is required.</td></tr>		<tr><td>Ledge</td><td>Signifies that the character will soon reach a ledge, and must jump <em>then</em>, not now.</td></tr>		<tr><td>Climb</td><td>Signifies that the character must climb a ladder or other such surface to traverse this link.		Note that <strong>Walkabout</strong> does not implement climbable surfaces; this feature is included for compatibility with your own modifications.</td></tr>		<tr><td>Teleport</td><td>This link is a teleporter.</td></tr>	</table>	<h2 id="cover-mode">Cover mode</h2>	<p><strong>Walkabout</strong> allows you to automatically generate cover points along the edges of a NavMesh.	These can be used in your AI scripts with the AIPlayer::findCover function (see the Scripting section below).	CoverPoints with different sizes and peek directions.</p>	<p>With a NavMesh selected, hit the 'create cover points' button to generate cover points on the selected mesh.	Don't forget to specify appropriate settings in Inspect mode first!	(Some relevant properties are shown below.)	You'll see cover points appear around the edges of your mesh.	They're all created as regular objects in the level, so you can edit them in the World editor if you find <strong>Walkabout</strong>'s automatic placement lacking,	or if you want to manually control the areas where the AI should take cover.</p>	<h3 id="cover-properties">Cover properties</h3>	<table class="table">		<tr><th>Member</th><th>Description</th></tr>		<tr><td>coverGroup</td> <td>The name of a SimGroup where the CoverPoints this NavMesh creates should be put.		<strong>WARNING!</strong> The NavMesh will delete everything in this group when you create its cover points, so don't use it for anything else!</td></tr>		<tr><td>coverDist</td> <td>The distance to search from a NavMesh edge to a cover surface.		If your NavMesh does not generate cover points in locations where the mesh edges are far from the walls, tey increasing this value.</td></tr>		<tr><td>peekDist</td> <td>The horizontal distance that determines whether a CoverPoint can 'peek' around a corner.</td></tr>		<tr><td>innerCover</td> <td>If checked, CoverPoints will be generated all along the edges of the NavMesh - if not, then they'll only be added at the corners.		<strong>WARNING!</strong> Enabling this option may generate a <strong>lot</strong> of CoverPoints!</td></tr>	</table>	<p>CoverPoints have several 'peek' directions.	This represents directions in which there is no geometry, suitable for characters hiding at that location to peek in.	Peek directions are represented as thin green arrows drawn on the CoverPoint.	Peek directions are only generated by <strong>Walkabout</strong> - it's your AI's responsibility to use them!	For more information, see the <a href="#scripting">Scripting</a> section below.</p>	<h2 id="tile-mode">Tile mode</h3>	<p>This mode allows you to view detailed information about each tile in the selected NavMesh and rebuild them individually if you so desire.	You can select a tile in the mesh by left-clicking it.	The currently-selected tile will render additional information according to the options set in the box to the right of the main editor window.</p>	<p>The render input option, when active, will render in pink the input geometry used to generate the NavMesh in that tile, as above.	The render voxels option renders the voxelised representation of that geometry.	These options help you to diagnose problems when the NavMesh has not come out the way you want it to!</p>	<img src="images/tile-input.png" /><img src="images/tile-voxels.png" />	<p class="caption">A piece of geometry with input, and its voxelisation.</p>	<p>With a tile selected, hit the 'build tile' button to rebuild the NavMesh just in that small location.</p>	<div class="alert alert-warning">		<p><strong>IMPORTANT!</strong>		If you don't have saveIntermediates checked in your NavMesh's properties when it is built, then you will not see any input or voxels rendered!</p>	</div>	<h2 id="test-mode">Test mode</h2>	<p>Test mode allows you to spawn and control AIPlayers, moving them around the level to test the NavMeshes you have created.	This mode exists mainly to allow you to quickly test that your NavMesh works appropriately for your level geometry - for example, checking tight corners and underhangs.</p>	<img src="images/test-mode.png" />	<p class="caption">A selected AIPlayer follows a path through the level.</p>	<ul>		<li>Ctrl-click on your level to create an AIPlayer object.		You can also click the 'Spawn' button in the Actions panel.		The datablock used is specified in the Nav Editor settings.</li>		<li>Left-click an AIPlayer to select it.</li>		<li>With an AIPlayer selected:		<ul>			<li>Delete a selected AIPlayer with the delete key.</li>			<li>Left-click on your level to make the character find a path to a destination.</li>			<li>Shift-left-click to deselect an AIPlayer.</li>		</ul></li>	</ul>	<p>The buttons in the actions box give you access to additional AIPlayer features.	You can make the AIPlayer find cover, or follow another object.	There's also a stop button in case you want them to stop chasing you!</p>	<img src="images/test-properties.png" />	<p class="caption">Properties and actions in Test mode.</p>	<p>The properties window lets you modify properties for following, cover-finding, and AIPlayer pathfinding.	The two text fields in the 'cover' section alter the cover search radius, and the location to find cover from, respectively.	The latter field can be a vector, or youcan enter a function.	By defult, the box gets the position of the object you are controlling, so AIPlayers will hide from your free camera or Player.	These properties are used when you press the 'Take cover' button in the actions box.	The fields under 'follow' determine the follow radius and the follow object when you click the 'Follow' button.	By default, AIPlayers will follow your Player.</p>	<p>The final section of the properties window contains checkboxes for the different types of terrain the currently-selected AIPlayer is allowed to use.	They apply to the currently-selected AIPlayer.</p>	<h1 id="scripting">Scripting</h1>	<p>This section will describe the script interface to <strong>Walkabout</strong>'s new classes and objects.</p>	<h2 id="scripting-aiplayer">AIPlayer</h2>	<p><strong>Walkabout</strong> provides lots of functions in the AIPlayer class to provide easy access to common navigation needs.</p>	<h3 id="aiplayer-pathfinding">Pathfinding</h3>	<p>To use pathfinding in your scripted AI, all you need to do is use the setPathDestination function:</p><pre><code>// Path to location (0, 20, 0)%player.setPathDestination("0 20 0");// Path to location of object %obj%player.setPathDestination(%obj.getPosition());</code></pre>	<h3 id="aiplayer-followpath">Following paths</h3>	<p>In addition to creating a new path through a level, characters can use existing NavPaths - for example, one you might have saved in your mission file.</p><pre><code>// Follow path named "myPath"%player.followNavPath("myPath");</code></pre>	<div class="alert alert-warning">		<p><strong>IMPORTANT!</strong>		Don't forget that the followNavPath function only works on NavPaths, not the regular kind of Path!		If you have an existing Path and you want a NavPath to follow it, use the NavPath's waypoints property.</p>	</div>	<h3 id="aiplayer-followobject">Following objects</h3>	<p><strong>Walkabout</strong> allows AIPlayers to follow other moving objects:</p><pre><code>// Send player 1 to location (0, 20, 0)%player1.setPathDestination("0 20 0");// Make player 2 follow player 1 at a distance of 5 metres%player2.followObject(%player1, 5);</code></pre>	<p>Followers will automatically keep up with the most recent location of their target.</p>	<h3 id="aiplayer-cover">Finding cover</h3>  <p>Finding cover is just as easy as finding a path.</p><pre><code>// Enemy is standing at (10, 4, 0)%cover = %player.findCover("10 4 0", 10);</code></pre>	<p>The findCover function takes two arguments, a location to find cover from and a maximum radius to search within.  You'll usually want to set the from location to the position of the closest attacking enemy!  It returns the ID of the cover point that was chosen, or <code>-1</code> if one wasn't.</p>	<p>Note that this function searches for CoverPoint objects nearby.	If your level doesn't have CoverPoints, you will need to add some manually via the World Editor, or automatically using <a href="#cover-mode">Cover mode</a> in the Nav editor.</p>  <p>At any time, you can also get the ID of the cover point the character is using:</p><pre><code>%cover = %player.getCoverPoint();</code></pre>  <p>It will return -1 if the character is not taking cover.</p>	<h3 id="character-types">Character types</h3>	<p>Included in <strong>Walkabout</strong> is the ability to specify a type for each character - one of Small, Regular and Large.	This type is used to determine which NavMeshes the character is allowed to use.	This lets you, for example, create one NavMesh for large characters and one for humanoids.	You can change a character's type using the setMeshSize command:</p><pre><code>// Make this character 'Large' type.%player.setNavSize("Large");// What size is this character?echo(%player.getNavSize());</code></pre>	<p>See the <a href="#inspect-mode">Inspect mode</a> reference for the NavMesh properties that interact with a character's mesh size.</p>	<h2 id="scripting-navmesh">NavMesh</h2>	<h3 id="navmesh-obstacles">Obstacles</h3>	<p>Sometimes, you just need to modify a NavMesh during gameplay.	It might be that damageable objects can be destroyed, or that players can build new structures that characters will need to navigate around.	The WalkaboutUpdate console functions lets you do this easily for all the NavMeshes in your level:</p><pre><code>// Update the area inside an object's world box.// For example, %obj has just been created.WalkaboutUpdateAll(%obj);// Notify all meshes that %obj's geometry should be removed.WalkaboutUpdateAll(%obj, true);// Update a specific NavMesh only.WalkaboutUpdateMesh(%mesh, %obj);// Remove object from a specific NavMesh only.WalkaboutUpdateMesh(%mesh, %obj, true);</code></pre>	<p>As you can see, adding 'true' as the last argument of these calls is used to notify NavMeshes that an object is about to be deleted.	With this flag set, when making the updates <strong>Walkabout</strong> will disable the object's collision, treating it as if it didn't exist for the duration of the update.</p>	<p>WalkaboutUpdate is defined in the engine, so you can use it even if you decide not to use my sample scripts.	However, walkaboutDynamic.cs does provide a namespace to do this for you automatically on object creation/removal.	See the reference for <a href=#walkaboutdynamic>WalkaboutDynamic</a>.</p>	<h3 id="navmesh-building">Building</h3>	<p>Just in case you ever want to build a NavMesh from a script, the NavMesh class provides easy methods to do so!</p><pre><code>// Build the entire NavMesh// The first argument is whether to build in the background (a good idea!)// The second argument is whether to save intermediate results (for debugging)%mesh.build(true, false);// Stop the build while in progress!%mesh.cancelBuild();// Store the mesh's cover points in this SimGroup:%mesh.coverGroup = MyMeshCoverPoints;// Build a mesh's CoverPoints%mesh.createCoverPoints();// And delete them again%mesh.deleteCoverPoints();// Build only the tiles of the NavMesh that overlap a box%mesh.buildTiles(%obj.getWorldBox());// Save a NavMesh to a file%mesh.fileName = "levels/myMesh.nm";%mesh.save();// Load from a file%mesh.fileName = "levels/myOtherMesh.nm";%mesh.load();</code></pre>	<h3 id="navmesh-links">Link manipulation</h3>	<p>There are also console functions to create, remove and edit links in a NavMesh.	Remember that after updating links, you should call the <code>buildLinks</code> function to make sure character navigation is up-to-date.	The code snippet below shows how to use the functions related to link manipulation.</p><pre><code>// Add a new link from a point to another point. It will be automatically classified// as 'drop' or 'jump'. Returns the ID number of the link%link = %mesh.addLink("20 30 10", "20 40 5");// Get the start and end points of the newly-added link%from = %mesh.getLinkStart(%link); // %from is now "20 30 10"%to = %mesh.getLinkEnd(%link);     // %to is now "20 40 5"// Get the flags associated with this link%flags = %mesh.getLinkFlags(%link);// Rebuild the mesh's links so characters can use the new link%mesh.buildLinks();// Get the number of links in the mesh%count = %mesh.getLinkCount();// Find a link near a given other position%otherLink = %mesh.getLink("100 20 3");// Transfer link's flags to other link's flags%mesh.setLinkFlags(%otherLink, %flags);// Delete it!%mesh.deleteLink(%otherLink);// Now delete all links%mesh.deleteLinks();// And update againmesh.buildLinks();</code></pre>	<h2 id="scripting-navpath">NavPath</h2>	<p>The NavPath class is what all character pathfinding in <strong>Walkabout</strong> is based on, providing a direct interface to Detour's pathfinding algorithms.	navPath's properties are described below:</p>	<table class="table">		<tr><th>Member</th><th>Description</th></tr>		<tr><td>from</td> <td>The location that this path starts.</td></tr>		<tr><td>to</td> <td>Goal location.</td></tr>		<tr><td>mesh</td> <td>The name or ID of the NavMesh that this path should use.</td></tr>		<tr><td>waypoints</td> <td>The name or ID of a regular Path that this NavPath should visit all the points of.</td></tr>		<tr><td>isLooping</td> <td>Does this path loop back to its start?</td></tr>		<tr><td>isSliced</td> <td>If checked, this NavPath will not be created instantly, but the pathfinding algorithm will be split over multiple updates.</td></tr>		<tr><td>maxIterations</td> <td>The maximum number of A* iterations per tick for a sliced path.</td></tr>		<tr><td>alwaysRender</td> <td>Render this NavPath even when not selected.</td></tr>		<tr><td>xray</td> <td>Render this NavPath through other objects.</td></tr>		<tr><td>renderSearch</td> <td>Render the closed list of this path's A* search. Best used with isSliced = true and maxIterations set to a low number.</td></tr>		<tr><td>allow*</td> <td>Allow the path to traverse this kind of terrain.</td></tr>	</table>	<p>NavPaths are automatically planned when they are created, but if you modify them in script, you can use the plan() method to update them:</p><pre><code>%path = new NavPath() {   mesh = "Nav";   from = "0 1 0";   to = "0 10 0";};// Path now goes from (0, 1, 0) to (0, 10, 0)// Change the destination!%path.to = "10 0 0";// And replan%path.plan();</code></pre>	<p>Each location in a path can be accessed by using the getNode function, like so:</p><pre><code>// Echo coordinates of all path pointsfor(%i = 0; %i < %path.size(); %i++) {   echo(%path.getNode(%i));}</code></pre>	<p>For convenience, NavPath defines a function to get its total length:</p><pre><code>// Get path length in metres%len = %path.getLength();</code></pre>	<h2 id="scripting-coverpoint">CoverPoint</h2>	<p>CoverPoint is a very simple class.	It has a few members that define how AIPlayers should see it when looking for cover.	They are described below:</p>	<table class="table">		<tr><th>Member</th><th>Description</th></tr>		<tr><td>size</td> <td>One of "Stand", "Crouch" and "Prone". Indicates how large this cover point is.</td></tr>		<tr><td>quality</td> <td>How good the cover is. <strong>Walkabout</strong> leaves this value at 1.0, but if you feel specific pieces of cover should be less desirable		(because of being behind a weak material, for example), then you can manually tweak the value in the World Editor.</td></tr>		<tr><td>peek*</td> <td>These flags indicate whether the terrain around the cover point allows characters to pee over in the appropriate direction.</td></tr>	</table></body></html>